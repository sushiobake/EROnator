#!/usr/bin/env tsx
/**
 * AIタグチェック結果の JSON を読み、各作品の manualTaggingFolder を更新する。
 * result が「タグ済」→ tagged、「人間による確認が必要」→ needs_human_check
 * Usage: npx tsx scripts/apply-check-result.ts <JSONファイルパス>
 */
import * as path from 'path';
import * as fs from 'fs';

const root = path.resolve(process.cwd());
function loadDatabaseUrl(): string | null {
  for (const name of ['.env.local', '.env']) {
    const p = path.join(root, name);
    if (!fs.existsSync(p)) continue;
    const content = fs.readFileSync(p, 'utf-8');
    for (const line of content.split('\n')) {
      const match = line.match(/^DATABASE_URL=(.+)$/);
      if (match) {
        const val = match[1].trim().replace(/^["']|["']$/g, '');
        if (val) return val;
        break;
      }
    }
  }
  return null;
}
const urlFromFile = loadDatabaseUrl();
if (urlFromFile) {
  const fileMatch = urlFromFile.match(/^file:(\.\/)?(.*?)(\?.*)?$/);
  if (fileMatch) {
    const absolutePath = path.resolve(root, fileMatch[2]);
    const suffix = fileMatch[3] || '';
    process.env.DATABASE_URL = 'file:' + absolutePath.replace(/\\/g, '/') + suffix;
  } else {
    process.env.DATABASE_URL = urlFromFile;
  }
} else {
  require('dotenv').config({ path: path.join(root, '.env') });
}

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

function toFolder(result: string): 'tagged' | 'needs_human_check' | null {
  const r = (result || '').trim();
  if (r === 'タグ済') return 'tagged';
  if (r === '人間による確認が必要') return 'needs_human_check';
  return null;
}

async function main() {
  const jsonPath = process.argv[2];
  if (!jsonPath) {
    console.error('Usage: npx tsx scripts/apply-check-result.ts <JSONファイルパス>');
    process.exit(1);
  }
  const absPath = path.isAbsolute(jsonPath) ? jsonPath : path.join(root, jsonPath);
  if (!fs.existsSync(absPath)) {
    console.error('ファイルが見つかりません:', absPath);
    process.exit(1);
  }
  const raw = fs.readFileSync(absPath, 'utf-8');
  type Item = { workId: string; result: string; tagChanges?: { added?: string[]; removed?: string[] } };
  let list: Item[];
  try {
    const parsed = JSON.parse(raw);
    list = Array.isArray(parsed) ? parsed : [parsed];
  } catch {
    console.error('JSON のパースに失敗しました。');
    process.exit(1);
  }

  const isPostgres = (process.env.DATABASE_URL ?? '').startsWith('postgres');

  if (isPostgres) {
    await prisma.$executeRawUnsafe('ALTER TABLE "Work" ADD COLUMN IF NOT EXISTS "lastCheckTagChanges" TEXT');
  } else {
    const tableInfo = await prisma.$queryRawUnsafe<Array<{ name: string }>>('PRAGMA table_info(Work)');
    if (!tableInfo.some((c) => c.name === 'lastCheckTagChanges')) {
      await prisma.$executeRawUnsafe('ALTER TABLE Work ADD COLUMN lastCheckTagChanges TEXT');
    }
  }

  const requestedWorkIds = [...new Set(list.map((item) => item.workId).filter(Boolean))] as string[];
  let works = await prisma.work.findMany({
    where: { workId: { in: requestedWorkIds } },
  });
  const foundIds = new Set(works.map((w) => w.workId));
  const missing = requestedWorkIds.filter((id) => !foundIds.has(id));
  if (missing.length > 0) {
    const alternateIds = missing.flatMap((id) =>
      id.startsWith('cid:') ? [id.replace(/^cid:/, '')] : ['cid:' + id]
    );
    const extra = await prisma.work.findMany({
      where: { workId: { in: alternateIds } },
    });
    works = [...works, ...extra];
  }
  const jsonToDbWorkId = new Map<string, string>();
  for (const w of works) {
    jsonToDbWorkId.set(w.workId, w.workId);
    if (w.workId.startsWith('cid:')) {
      jsonToDbWorkId.set(w.workId.replace(/^cid:/, ''), w.workId);
    } else {
      jsonToDbWorkId.set('cid:' + w.workId, w.workId);
    }
  }

  // 逆順で処理する: JSON の先頭の作品を最後に更新し、taggedAt を最も新しくする。
  // タグ済み一覧は ORDER BY taggedAt DESC のため、チェック結果と同じ順で上から並ぶ。
  const listToProcess = [...list].reverse();
  let updated = 0;
  let skipped = 0;
  for (const item of listToProcess) {
    const workId = item.workId;
    if (!workId) {
      skipped++;
      continue;
    }
    const actualWorkId = jsonToDbWorkId.get(workId);
    if (!actualWorkId) {
      console.warn('DBに存在しない workId のためスキップ:', workId);
      skipped++;
      continue;
    }
    const folder = toFolder(item.result);
    if (!folder) {
      console.warn('不明な result のためスキップ:', workId, item.result);
      skipped++;
      continue;
    }
    const tagChangesJson =
      folder === 'needs_human_check'
        ? JSON.stringify(item.tagChanges ?? { added: [], removed: [] })
        : null;

    if (isPostgres) {
      if (folder === 'tagged') {
        await prisma.$executeRawUnsafe(
          'UPDATE "Work" SET "manualTaggingFolder" = $1, "updatedAt" = NOW(), "taggedAt" = NOW(), "lastCheckTagChanges" = NULL WHERE "workId" = $2',
          folder,
          actualWorkId
        );
      } else {
        await prisma.$executeRawUnsafe(
          'UPDATE "Work" SET "manualTaggingFolder" = $1, "updatedAt" = NOW(), "lastCheckTagChanges" = $3 WHERE "workId" = $2',
          folder,
          actualWorkId,
          tagChangesJson
        );
      }
    } else {
      if (folder === 'tagged') {
        await prisma.$executeRawUnsafe(
          'UPDATE Work SET manualTaggingFolder = ?, updatedAt = datetime(\'now\'), taggedAt = datetime(\'now\'), lastCheckTagChanges = NULL WHERE workId = ?',
          folder,
          actualWorkId
        );
      } else {
        await prisma.$executeRawUnsafe(
          'UPDATE Work SET manualTaggingFolder = ?, updatedAt = datetime(\'now\'), lastCheckTagChanges = ? WHERE workId = ?',
          folder,
          tagChangesJson,
          actualWorkId
        );
      }
    }
    updated++;
  }
  console.log('反映完了:', updated, '件更新', skipped > 0 ? `, ${skipped} 件スキップ` : '');
}

main()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });
